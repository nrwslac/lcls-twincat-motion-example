<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="Main" Id="{7b41e58a-08f0-4959-90b4-af08ef5cbf10}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM Main
VAR
    // Simulated motor that is always allowed to move
    {attribute 'pytmc' := '
        pv: M9X9:TST:MMS:XUP
        field: DESC Simulated Working Motor
    '}
    M1: DUT_MotionStage;
    fbMotion1: FB_MotionStageSim;
    
    {attribute 'pytmc' := '
      pv: M9X9:TST:MIRROR:STATE:SET
      io: i
    '}
    M9X9_Mirror_enumSet : ENUM_Mirror_States;
    {attribute 'pytmc' := '
     pv: M9X9:TST:MIRROR:STATE;
     io: i;
     field: ZRST Unknown ;
     field: ONST IN;
     field: TWST OUT;
     '}
    
    fbM9X9_States: FB_Mirror_States := (
        bEnable := TRUE,
        sINtype := 'IN',
        nINPosition := 1100,
        fINDelta := 50,
        fINVelocity := 100
        );

    // Simulated motor that is never allowed to move
    {attribute 'pytmc' := '
        pv: PLC:TST:MOT:SIM:02
        field: DESC Simulated Broken Motor
    '}
    M2: DUT_MotionStage;
    fbMotion2: FB_MotionStage;

    // Simulated motor with limits at 0 and 100
    {attribute 'pytmc' := '
        pv: PLC:TST:MOT:SIM:03
        field: DESC Simulated Working Motor With Limits
    '}
    M3: DUT_MotionStage;
    fbMotion3: FB_MotionStage;
    
    // Simulated PPM motor with PMPS
    {attribute 'pytmc' := '
        pv: PLC:TST:MOT:SIM:04
        field: DESC Simulated PPM Motor
    '}
    M4: DUT_MotionStage;
    {attribute 'pytmc' := '
        pv: PLC:TST:MOT:SIM:04
    '}
    fbPPM: FB_PPM;
    
    // PMPS Machinery
    fbArbiterIO: FB_SubSysToArbiter_IO;
    {attribute 'pytmc' := 'pv: PLC:TST:MOT:ARB'}
    fbArbiter: FB_Arbiter(1);
    {attribute 'pytmc' := 'pv: PLC:TST:MOT:FFO:01'}
    fbFFHWO: FB_HardwareFFOutput := (bAutoReset := TRUE);
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbMotion1(stMotionStage := M1);
fbMotion2(stMotionStage := M2);

M3.bHardwareEnable := TRUE;
M3.bPowerSelf := TRUE;
M3.bLimitForwardEnable := M3.Axis.NcToPlc.ActPos < 99.7;
M3.bLimitBackwardEnable := M3.Axis.NcToPlc.ActPos > 0.2;

fbMotion3(stMotionStage := M3);

fbM9X9_States(
    enumSet := M9X9_Mirror_enumSet,
    stMotionStage := M1,
    fbArbiter := fbArbiter,
    fbFFHWO := fbFFHWO);
    
M9X9_Mirror_enumSet := fbM9X9_States.setState;

M4.bHardwareEnable := TRUE;
M4.bPowerSelf := FALSE;
M4.bLimitForwardEnable := TRUE;
M4.bLimitBackwardEnable := TRUE;

fbPPM.nTransitionAssertionID := 16#2FF0;
fbPPM.nUnknownAssertionID := 16#2FF9;
fbPPM.stOut.fPosition := -10;
fbPPM.stOut.bUseRawCounts := FALSE;
fbPPM.stOut.nRequestAssertionID := 16#2FF1;
fbPPM.stOut.stBeamParams := PMPS_GVL.cstFullBeam;
fbPPM.stOut.bValid := TRUE;
fbPPM.stPower.fPosition := -50;
fbPPM.stPower.bUseRawCounts := FALSE;
fbPPM.stPower.nRequestAssertionID := 16#2FF2;
fbPPM.stPower.stBeamParams := PMPS_GVL.cstFullBeam;
fbPPM.stPower.bValid := TRUE;
fbPPM.stYag1.fPosition := -70;
fbPPM.stYag1.bUseRawCounts := FALSE;
fbPPM.stYag1.nRequestAssertionID := 16#2FF3;
fbPPM.stYag1.stBeamParams := PMPS_GVL.cstFullBeam;
fbPPM.stYag1.bValid := TRUE;
fbPPM.stYag2.fPosition := -100;
fbPPM.stYag2.bUseRawCounts := FALSE;
fbPPM.stYag2.nRequestAssertionID := 16#2FF4;
fbPPM.stYag2.stBeamParams := PMPS_GVL.cstFullBeam;
fbPPM.stYag2.bValid := TRUE;

fbPPM(
    stYStage:=M4,
    fbArbiter:=fbArbiter,
    fbFFHWO:=fbFFHWO,
    );
    
fbFFHWO.Execute();
fbArbiterIO(
    Arbiter:=fbArbiter,
    fbFFHWO:=fbFFHWO);]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>